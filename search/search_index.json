{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Suspycious","text":"<p>Suspycious is a Python implementation of the Sus protocol. It is a  secure, asynchronous, and easy to use protocol for sending messages between two parties.</p> <p>Pre-alpha software</p> <p>Suspycious is currently in an early stage of development and should not be used in production.</p>"},{"location":"#installation","title":"Installation","text":"<p>Suspycious is available on PyPI and can be installed with pip:</p> <pre><code>pip install suspycious\n</code></pre>"},{"location":"#usage","title":"Usage","text":"<p>The following example shows how to create a simple Sus network with a client and a server. The client sends a message to the server and the server responds with a message.</p> <pre><code>import asyncio\n\nfrom sus import SusServer\n\n\n\nserver = SusServer(('localhost', 5000), b\"my secret key\")\n\nasync def message_handler(addr: tuple[str, int], p_id: int, message: bytes):\n    print(f\"Received message from {addr}: {message.decode()}\")\n    server.send(addr, b\"Hello from the server!\")\n\nasyncio.run(server.start([message_handler]))\n</code></pre> <pre><code>import asyncio\n\nfrom sus import SusClient\n\nclient = SusClient(('localhost', 5000), b\"server public key\")\nasyncio.run(client.start())\nclient.send(b\"Hello from the client!\")\n</code></pre>"},{"location":"client/","title":"Client","text":""},{"location":"client/#susclient","title":"SusClient","text":"<p>This class is responsible for managing the client.</p> Source code in <code>sus/client/client.py</code> <pre><code>class SusClient:\n    \"\"\"\n    This class is responsible for managing the client.\n    \"\"\"\n    protocol: SusClientProtocol\n\n    def __init__(self, addr: tuple[str, int], ppks: str, protocol_id: bytes):\n        \"\"\"\n        Initializes the client.\n        :param addr: Server address\n        :param ppks: Server public key\n        :param protocol_id:  Protocol ID (any bytestring)\n        \"\"\"\n        self.server_addr = addr\n        self.ppks = X25519PublicKey.from_public_bytes(bytes.fromhex(ppks))\n        self.protocol_id = protocol_id\n\n        self.logger = logging.getLogger(f\"sussus\")\n\n    def __del__(self):\n        self.disconnect()\n\n    @property\n    def connected(self):\n        \"\"\"\n        True if the client is connected to the server.\n        \"\"\"\n        return hasattr(self, \"protocol\") and self.protocol.state == ConnectionState.CONNECTED\n\n    async def start(self, handlers: Iterable[MessageHandler] = None):\n        \"\"\"\n        This coroutine is responsible for starting the client. Blocks until the client is connected.\n        It also registers message handlers, called when a message is received.\n        :param handlers:\n        :return:\n        \"\"\"\n        await self.connect()\n        for handler in handlers or []:\n            self.protocol.add_message_handler(handler)\n\n    def __key_exchange(self, epks_ns_port: bytes, wallet: Wallet) -&gt; Wallet:\n        \"\"\"\n        This function is responsible for performing the key exchange.\n        :param epks_ns_port: received (epks, ns, port) from server\n        :param wallet: wallet containing the client's keys\n        :return: wallet containing the shared secret\n        \"\"\"\n\n        if len(epks_ns_port) != 40:\n            raise MalformedPacket(\"Invalid key response length\")\n        # 4. receive (epks, ns, port) from server\n        wallet.epks = X25519PublicKey.from_public_bytes(epks_ns_port[:32])\n        wallet.ns = epks_ns_port[32:40]\n        self.logger.info(\"received keys, starting handshake\")\n        # 5. compute ecps = X25519(eskc, ppks)\n        ecps = wallet.eskc.exchange(wallet.ppks)\n        eces = wallet.eskc.exchange(wallet.epks)\n        # 6. compute key = H(eces, ecps, nc, ns, ppks, epks, epkc)\n        wallet.shared_secret = blake3(\n            eces + ecps + wallet.nc + wallet.ns +\n            wallet.ppks.public_bytes(Encoding.Raw, PublicFormat.Raw) +\n            wallet.epks.public_bytes(Encoding.Raw, PublicFormat.Raw) +\n            wallet.epkc.public_bytes(Encoding.Raw, PublicFormat.Raw)).digest()\n        self.logger.info(\"shared secret: %s\", wallet.shared_secret.hex())\n\n        # 7. compute token = H(epkc, epks, nc, ns)\n        self.logger.info(\"\\n\".join([\n            f\"epkc: {wallet.epkc.public_bytes(Encoding.Raw, PublicFormat.Raw).hex()}\",\n            f\"epks: {wallet.epks.public_bytes(Encoding.Raw, PublicFormat.Raw).hex()}\",\n            f\"nc: {wallet.nc.hex()}\",\n            f\"ns: {wallet.ns.hex()}\"\n        ]))\n        wallet.token = blake3(wallet.epkc.public_bytes(Encoding.Raw, PublicFormat.Raw) +\n                              wallet.epks.public_bytes(Encoding.Raw, PublicFormat.Raw) +\n                              wallet.nc + wallet.ns).digest()\n        return wallet\n\n    async def connect(self):\n        \"\"\"\n        This coroutine is responsible for connecting to the server.\n        Performs the key exchange and starts the handshake.\n        \"\"\"\n        self.logger.info(f\"connecting to server ({self.server_addr[0]}:{self.server_addr[1]})\")\n\n        sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n        sock.connect(self.server_addr)\n        sock.setblocking(False)\n        sock.settimeout(5)\n\n        eskc = X25519PrivateKey.generate()\n        epkc = eskc.public_key()\n        nc = urandom(8)\n        wallet = Wallet(ppks=self.ppks, eskc=eskc, epkc=epkc, nc=nc)\n\n        # try:\n        sock.send(wallet.epkc.public_bytes(Encoding.Raw, PublicFormat.Raw) + wallet.nc)\n        data = sock.recv(40)\n        # except (ConnectionError, TimeoutError):\n        #     self.logger.error(\"failed to connect to server\")\n        # return False\n\n        wallet = self.__key_exchange(data, wallet)\n\n        self.logger.info(\"received keys, starting handshake\")\n\n        _, self.protocol = await asyncio.get_event_loop().create_datagram_endpoint(\n            lambda: SusClientProtocol(wallet, self.protocol_id),\n            sock=sock\n        )\n        await self.protocol.handshake_event.wait()\n        # return True\n\n    def send(self, data: bytes):\n        \"\"\"\n        Sends a message to the server.\n        :param data: message to send as bytes\n        \"\"\"\n        if not self.protocol:\n            self.logger.warning(\"not connected to server\")\n            return\n        self.protocol.send(data)\n\n    def disconnect(self):\n        \"\"\"\n        Disconnects from the server.\n        \"\"\"\n        if not hasattr(self, \"protocol\"):\n            self.logger.warning(\"not connected to server\")\n            return\n        try:\n            asyncio.get_running_loop()\n            self.protocol.disconnect()\n        except RuntimeError:  # not running in event loop\n            pass\n        self.logger.info(f\"disconnected from server ({self.server_addr[0]}:{self.server_addr[1]})\")\n\n    async def keep_alive(self):\n        \"\"\"\n        Convenience coroutine that waits until the client is disconnected.\n        \"\"\"\n        if not hasattr(self, \"protocol\"):\n            self.logger.warning(\"not connected to server\")\n            return\n        try:\n            await self.protocol.diconnection_event.wait()\n        except asyncio.CancelledError:\n            self.logger.info(\"exiting...\")\n</code></pre>"},{"location":"client/#sus.client.client.SusClient.connected","title":"<code>connected</code>  <code>property</code>","text":"<p>True if the client is connected to the server.</p>"},{"location":"client/#sus.client.client.SusClient.__init__","title":"<code>__init__(addr, ppks, protocol_id)</code>","text":"<p>Initializes the client.</p> <p>Parameters:</p> Name Type Description Default <code>addr</code> <code>tuple[str, int]</code> <p>Server address</p> required <code>ppks</code> <code>str</code> <p>Server public key</p> required <code>protocol_id</code> <code>bytes</code> <p>Protocol ID (any bytestring)</p> required Source code in <code>sus/client/client.py</code> <pre><code>def __init__(self, addr: tuple[str, int], ppks: str, protocol_id: bytes):\n    \"\"\"\n    Initializes the client.\n    :param addr: Server address\n    :param ppks: Server public key\n    :param protocol_id:  Protocol ID (any bytestring)\n    \"\"\"\n    self.server_addr = addr\n    self.ppks = X25519PublicKey.from_public_bytes(bytes.fromhex(ppks))\n    self.protocol_id = protocol_id\n\n    self.logger = logging.getLogger(f\"sussus\")\n</code></pre>"},{"location":"client/#sus.client.client.SusClient.__key_exchange","title":"<code>__key_exchange(epks_ns_port, wallet)</code>","text":"<p>This function is responsible for performing the key exchange.</p> <p>Parameters:</p> Name Type Description Default <code>epks_ns_port</code> <code>bytes</code> <p>received (epks, ns, port) from server</p> required <code>wallet</code> <code>Wallet</code> <p>wallet containing the client's keys</p> required <p>Returns:</p> Type Description <code>Wallet</code> <p>wallet containing the shared secret</p> Source code in <code>sus/client/client.py</code> <pre><code>def __key_exchange(self, epks_ns_port: bytes, wallet: Wallet) -&gt; Wallet:\n    \"\"\"\n    This function is responsible for performing the key exchange.\n    :param epks_ns_port: received (epks, ns, port) from server\n    :param wallet: wallet containing the client's keys\n    :return: wallet containing the shared secret\n    \"\"\"\n\n    if len(epks_ns_port) != 40:\n        raise MalformedPacket(\"Invalid key response length\")\n    # 4. receive (epks, ns, port) from server\n    wallet.epks = X25519PublicKey.from_public_bytes(epks_ns_port[:32])\n    wallet.ns = epks_ns_port[32:40]\n    self.logger.info(\"received keys, starting handshake\")\n    # 5. compute ecps = X25519(eskc, ppks)\n    ecps = wallet.eskc.exchange(wallet.ppks)\n    eces = wallet.eskc.exchange(wallet.epks)\n    # 6. compute key = H(eces, ecps, nc, ns, ppks, epks, epkc)\n    wallet.shared_secret = blake3(\n        eces + ecps + wallet.nc + wallet.ns +\n        wallet.ppks.public_bytes(Encoding.Raw, PublicFormat.Raw) +\n        wallet.epks.public_bytes(Encoding.Raw, PublicFormat.Raw) +\n        wallet.epkc.public_bytes(Encoding.Raw, PublicFormat.Raw)).digest()\n    self.logger.info(\"shared secret: %s\", wallet.shared_secret.hex())\n\n    # 7. compute token = H(epkc, epks, nc, ns)\n    self.logger.info(\"\\n\".join([\n        f\"epkc: {wallet.epkc.public_bytes(Encoding.Raw, PublicFormat.Raw).hex()}\",\n        f\"epks: {wallet.epks.public_bytes(Encoding.Raw, PublicFormat.Raw).hex()}\",\n        f\"nc: {wallet.nc.hex()}\",\n        f\"ns: {wallet.ns.hex()}\"\n    ]))\n    wallet.token = blake3(wallet.epkc.public_bytes(Encoding.Raw, PublicFormat.Raw) +\n                          wallet.epks.public_bytes(Encoding.Raw, PublicFormat.Raw) +\n                          wallet.nc + wallet.ns).digest()\n    return wallet\n</code></pre>"},{"location":"client/#sus.client.client.SusClient.connect","title":"<code>connect()</code>  <code>async</code>","text":"<p>This coroutine is responsible for connecting to the server. Performs the key exchange and starts the handshake.</p> Source code in <code>sus/client/client.py</code> <pre><code>async def connect(self):\n    \"\"\"\n    This coroutine is responsible for connecting to the server.\n    Performs the key exchange and starts the handshake.\n    \"\"\"\n    self.logger.info(f\"connecting to server ({self.server_addr[0]}:{self.server_addr[1]})\")\n\n    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n    sock.connect(self.server_addr)\n    sock.setblocking(False)\n    sock.settimeout(5)\n\n    eskc = X25519PrivateKey.generate()\n    epkc = eskc.public_key()\n    nc = urandom(8)\n    wallet = Wallet(ppks=self.ppks, eskc=eskc, epkc=epkc, nc=nc)\n\n    # try:\n    sock.send(wallet.epkc.public_bytes(Encoding.Raw, PublicFormat.Raw) + wallet.nc)\n    data = sock.recv(40)\n    # except (ConnectionError, TimeoutError):\n    #     self.logger.error(\"failed to connect to server\")\n    # return False\n\n    wallet = self.__key_exchange(data, wallet)\n\n    self.logger.info(\"received keys, starting handshake\")\n\n    _, self.protocol = await asyncio.get_event_loop().create_datagram_endpoint(\n        lambda: SusClientProtocol(wallet, self.protocol_id),\n        sock=sock\n    )\n    await self.protocol.handshake_event.wait()\n</code></pre>"},{"location":"client/#sus.client.client.SusClient.disconnect","title":"<code>disconnect()</code>","text":"<p>Disconnects from the server.</p> Source code in <code>sus/client/client.py</code> <pre><code>def disconnect(self):\n    \"\"\"\n    Disconnects from the server.\n    \"\"\"\n    if not hasattr(self, \"protocol\"):\n        self.logger.warning(\"not connected to server\")\n        return\n    try:\n        asyncio.get_running_loop()\n        self.protocol.disconnect()\n    except RuntimeError:  # not running in event loop\n        pass\n    self.logger.info(f\"disconnected from server ({self.server_addr[0]}:{self.server_addr[1]})\")\n</code></pre>"},{"location":"client/#sus.client.client.SusClient.keep_alive","title":"<code>keep_alive()</code>  <code>async</code>","text":"<p>Convenience coroutine that waits until the client is disconnected.</p> Source code in <code>sus/client/client.py</code> <pre><code>async def keep_alive(self):\n    \"\"\"\n    Convenience coroutine that waits until the client is disconnected.\n    \"\"\"\n    if not hasattr(self, \"protocol\"):\n        self.logger.warning(\"not connected to server\")\n        return\n    try:\n        await self.protocol.diconnection_event.wait()\n    except asyncio.CancelledError:\n        self.logger.info(\"exiting...\")\n</code></pre>"},{"location":"client/#sus.client.client.SusClient.send","title":"<code>send(data)</code>","text":"<p>Sends a message to the server.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>bytes</code> <p>message to send as bytes</p> required Source code in <code>sus/client/client.py</code> <pre><code>def send(self, data: bytes):\n    \"\"\"\n    Sends a message to the server.\n    :param data: message to send as bytes\n    \"\"\"\n    if not self.protocol:\n        self.logger.warning(\"not connected to server\")\n        return\n    self.protocol.send(data)\n</code></pre>"},{"location":"client/#sus.client.client.SusClient.start","title":"<code>start(handlers=None)</code>  <code>async</code>","text":"<p>This coroutine is responsible for starting the client. Blocks until the client is connected. It also registers message handlers, called when a message is received.</p> <p>Parameters:</p> Name Type Description Default <code>handlers</code> <code>Iterable[MessageHandler]</code> <code>None</code> <p>Returns:</p> Type Description Source code in <code>sus/client/client.py</code> <pre><code>async def start(self, handlers: Iterable[MessageHandler] = None):\n    \"\"\"\n    This coroutine is responsible for starting the client. Blocks until the client is connected.\n    It also registers message handlers, called when a message is received.\n    :param handlers:\n    :return:\n    \"\"\"\n    await self.connect()\n    for handler in handlers or []:\n        self.protocol.add_message_handler(handler)\n</code></pre>"},{"location":"client/#protocol","title":"Protocol","text":"<p>             Bases: <code>DatagramProtocol</code></p> <p>This class is responsible for handling the UDP protocol.</p> Source code in <code>sus/client/protocol.py</code> <pre><code>class SusClientProtocol(asyncio.DatagramProtocol):\n    \"\"\"\n    This class is responsible for handling the UDP protocol.\n    \"\"\"\n    transport: asyncio.DatagramTransport\n    state: ConnectionState\n\n    def __init__(self, wallet: Wallet, protcol_id: bytes,\n                 handlers: Optional[Iterable[MessageHandler]] = None):\n        \"\"\"\n        Initializes the client protocol.\n        :param wallet: wallet containing the client's keys\n        :param protcol_id: protocol ID (any bytestring)\n        :param handlers: message handlers, called when a message is received\n        \"\"\"\n        super().__init__()\n\n        self.wallet = wallet\n        self.protocol_id = protcol_id\n        self.state = ConnectionState.INITIAL\n\n        self.logger = logging.getLogger(f\"sus-cl\")\n\n        self.last_seen = now()\n\n        self.cl_enc = Cipher(ChaCha20(wallet.shared_secret, b\"\\x00\" * 8 + CLIENT_ENC_NONCE), None).encryptor()\n        self.sr_enc = Cipher(ChaCha20(wallet.shared_secret, b\"\\x00\" * 8 + SERVER_ENC_NONCE), None).decryptor()\n        self.cl_mac = Cipher(ChaCha20(wallet.shared_secret, b\"\\x00\" * 8 + CLIENT_MAC_NONCE), None).encryptor()\n        self.sr_mac = Cipher(ChaCha20(wallet.shared_secret, b\"\\x00\" * 8 + SERVER_MAC_NONCE), None).decryptor()\n\n        self.client_message_id = 0\n        self.server_message_id = 0\n        self.client_packet_id = 0\n        self.server_packet_id = 0\n\n        self.mtu_estimate = 1500\n\n        self.message_handlers: set[MessageHandler] = set(handlers or [])\n        self.handshake_event = asyncio.Event()\n        self.diconnection_event = asyncio.Event()\n\n    def add_message_handler(self, handler: MessageHandler):\n        self.message_handlers.add(handler)\n\n    def connection_made(self, transport: asyncio.DatagramTransport):\n        \"\"\"\n        This function is called when the connection is established.\n        :param transport: transport object, used to send and receive packets\n        \"\"\"\n        self.transport = transport\n        self.state = ConnectionState.HANDSHAKE\n        self.send(self.protocol_id, self.wallet.token)\n        self.state = ConnectionState.CONNECTED\n        self.last_seen = now()\n        self.logger.debug(\"Handshake complete\")\n        self.handshake_event.set()\n\n    def datagram_received(self, data: bytes, _addr: tuple[str, int]):\n        \"\"\"\n        This function is called when a packet is received.\n        :param data: packet data\n        :param _addr: originating address (always the server, unused)\n        \"\"\"\n\n        match self.state:\n            case ConnectionState.CONNECTED:\n                pid, message = self.__verify_and_decrypt(data)\n                self.logger.info(f\"&gt;&gt;&gt; {trail_off(message.decode('utf-8')) if message else None}\")\n                self.handle_message(pid, message)\n\n    def __verify_and_decrypt(self, data: bytes) -&gt; tuple[None, None] | tuple[int, bytes]:\n        \"\"\"\n        This function is responsible for verifying the packet and decrypting it.\n        :param data: data to verify and decrypt\n        :return: packet ID and message, or None if the packet is invalid\n        \"\"\"\n        try:\n            key = self.sr_mac.update(b\"\\x00\" * 32)\n            p_id = data[:8]\n            payload = data[8:-16]\n            tag = data[-16:]\n            frame = p_id + payload\n            poly1305.Poly1305.verify_tag(key, frame, tag)\n        except poly1305.InvalidSignature:\n            self.logger.error(\"Invalid signature\")\n            return None, None\n\n        p_id = int.from_bytes(p_id, \"little\")\n        message_bytes = self.sr_enc.update(payload)\n        message_length = int.from_bytes(message_bytes[:4], \"little\")\n        message: bytes = message_bytes[4:message_length + 4]\n        # self.logger.info(f\"Received message {p_id} ({message_length} bytes)\")\n        self.last_seen = now()\n        self.server_packet_id = p_id\n        return p_id, message\n\n    def __split_message(self, data: bytes) -&gt; list[bytes]:\n        \"\"\"\n        This function is responsible for splitting a message into packets.\n        :param data: data to split\n        :return: list of packets\n        \"\"\"\n        packet_length = self.mtu_estimate - 24\n        return [data[i:i + packet_length] for i in range(0, len(data), packet_length)]\n\n    def __encrypt_and_tag(self, data: bytes, token: bytes) -&gt; list[bytes]:\n        \"\"\"\n        This function is responsible for encrypting and tagging a message. Uses the ChaCha20-Poly1305 AEAD to\n        encrypt and authenticate the message.\n        :param data: data to encrypt\n        :param token: optional token to include in the first packet\n        :return: packets containing the encrypted and tagged message to send to the server\n        \"\"\"\n        message_bytes = len(data).to_bytes(4, \"little\") + data\n        packet_length = self.mtu_estimate - 24\n        padded_message_bytes = message_bytes + b\"\\x00\" * (\n                packet_length - ((len(message_bytes) + len(token)) % packet_length))\n\n        ciphertext = self.cl_enc.update(padded_message_bytes)\n        self.logger.debug(f\"--- {trail_off(ciphertext.hex())}\")\n        if token:\n            self.logger.debug(f\"TOK {trail_off(token.hex())}\")\n\n        payloads = self.__split_message(token + ciphertext)\n\n        packets = []\n        for payload in payloads:\n            key = self.cl_mac.update(b\"\\x00\" * 32)\n            p_id = self.client_packet_id.to_bytes(8, \"little\")\n            frame = p_id + payload\n            tag = poly1305.Poly1305.generate_tag(key, frame)\n            packets.append(frame + tag)\n            self.client_packet_id += 1\n        return packets\n\n    def send(self, data: bytes, token: bytes = b\"\"):\n        \"\"\"\n        This function is responsible for sending a message to the server.\n        :param data: data to send\n        :param token: token to include in the first packet. DO NOT INCLUDE THE TOKEN IN SUBSEQUENT PACKETS --\n                      a MalformedPacket error will be raised!\n        :raises MalformedPacket: if the token is included in a subsequent packet\n        \"\"\"\n        if self.state not in (ConnectionState.CONNECTED, ConnectionState.HANDSHAKE):\n            return\n        if token and self.client_packet_id != 0:\n            raise MalformedPacket(\"Token can only be included in the first packet\")\n        self.logger.info(f\"&lt;&lt;&lt; {trail_off(data.decode('utf-8'))}\")\n        packets = self.__encrypt_and_tag(data, token)\n        self.logger.info(f\"Sending {len(data)} bytes in {len(packets)} packets\")\n        for packet in packets:\n            self.transport.sendto(packet, None)\n\n    def disconnect(self):\n        \"\"\"\n        Disconnects the client from the server.\n        \"\"\"\n        self.logger.warning(\"Disconnecting from server...\")\n        self.transport.close()\n\n    def connection_lost(self, exc):\n        \"\"\"\n        Called when the connection is lost. Sets the disconnection event.\n        :param exc: exception raised, if any\n        \"\"\"\n        self.logger.warning(\"Connection to server lost\")\n        if exc:\n            self.logger.exception(exc)\n            self.state = ConnectionState.ERROR\n        else:\n            self.state = ConnectionState.DISCONNECTED\n        self.diconnection_event.set()\n\n    def handle_message(self, pid: int, message: bytes):\n        \"\"\"\n        Calls all message handlers asynchronously.\n        :param pid: packet ID\n        :param message: message bytes\n        :return:\n        \"\"\"\n        asyncio.gather(*[handler((\"\", 0), pid, message) for handler in self.message_handlers])\n</code></pre>"},{"location":"client/#sus.client.protocol.SusClientProtocol.__encrypt_and_tag","title":"<code>__encrypt_and_tag(data, token)</code>","text":"<p>This function is responsible for encrypting and tagging a message. Uses the ChaCha20-Poly1305 AEAD to encrypt and authenticate the message.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>bytes</code> <p>data to encrypt</p> required <code>token</code> <code>bytes</code> <p>optional token to include in the first packet</p> required <p>Returns:</p> Type Description <code>list[bytes]</code> <p>packets containing the encrypted and tagged message to send to the server</p> Source code in <code>sus/client/protocol.py</code> <pre><code>def __encrypt_and_tag(self, data: bytes, token: bytes) -&gt; list[bytes]:\n    \"\"\"\n    This function is responsible for encrypting and tagging a message. Uses the ChaCha20-Poly1305 AEAD to\n    encrypt and authenticate the message.\n    :param data: data to encrypt\n    :param token: optional token to include in the first packet\n    :return: packets containing the encrypted and tagged message to send to the server\n    \"\"\"\n    message_bytes = len(data).to_bytes(4, \"little\") + data\n    packet_length = self.mtu_estimate - 24\n    padded_message_bytes = message_bytes + b\"\\x00\" * (\n            packet_length - ((len(message_bytes) + len(token)) % packet_length))\n\n    ciphertext = self.cl_enc.update(padded_message_bytes)\n    self.logger.debug(f\"--- {trail_off(ciphertext.hex())}\")\n    if token:\n        self.logger.debug(f\"TOK {trail_off(token.hex())}\")\n\n    payloads = self.__split_message(token + ciphertext)\n\n    packets = []\n    for payload in payloads:\n        key = self.cl_mac.update(b\"\\x00\" * 32)\n        p_id = self.client_packet_id.to_bytes(8, \"little\")\n        frame = p_id + payload\n        tag = poly1305.Poly1305.generate_tag(key, frame)\n        packets.append(frame + tag)\n        self.client_packet_id += 1\n    return packets\n</code></pre>"},{"location":"client/#sus.client.protocol.SusClientProtocol.__init__","title":"<code>__init__(wallet, protcol_id, handlers=None)</code>","text":"<p>Initializes the client protocol.</p> <p>Parameters:</p> Name Type Description Default <code>wallet</code> <code>Wallet</code> <p>wallet containing the client's keys</p> required <code>protcol_id</code> <code>bytes</code> <p>protocol ID (any bytestring)</p> required <code>handlers</code> <code>Optional[Iterable[MessageHandler]]</code> <p>message handlers, called when a message is received</p> <code>None</code> Source code in <code>sus/client/protocol.py</code> <pre><code>def __init__(self, wallet: Wallet, protcol_id: bytes,\n             handlers: Optional[Iterable[MessageHandler]] = None):\n    \"\"\"\n    Initializes the client protocol.\n    :param wallet: wallet containing the client's keys\n    :param protcol_id: protocol ID (any bytestring)\n    :param handlers: message handlers, called when a message is received\n    \"\"\"\n    super().__init__()\n\n    self.wallet = wallet\n    self.protocol_id = protcol_id\n    self.state = ConnectionState.INITIAL\n\n    self.logger = logging.getLogger(f\"sus-cl\")\n\n    self.last_seen = now()\n\n    self.cl_enc = Cipher(ChaCha20(wallet.shared_secret, b\"\\x00\" * 8 + CLIENT_ENC_NONCE), None).encryptor()\n    self.sr_enc = Cipher(ChaCha20(wallet.shared_secret, b\"\\x00\" * 8 + SERVER_ENC_NONCE), None).decryptor()\n    self.cl_mac = Cipher(ChaCha20(wallet.shared_secret, b\"\\x00\" * 8 + CLIENT_MAC_NONCE), None).encryptor()\n    self.sr_mac = Cipher(ChaCha20(wallet.shared_secret, b\"\\x00\" * 8 + SERVER_MAC_NONCE), None).decryptor()\n\n    self.client_message_id = 0\n    self.server_message_id = 0\n    self.client_packet_id = 0\n    self.server_packet_id = 0\n\n    self.mtu_estimate = 1500\n\n    self.message_handlers: set[MessageHandler] = set(handlers or [])\n    self.handshake_event = asyncio.Event()\n    self.diconnection_event = asyncio.Event()\n</code></pre>"},{"location":"client/#sus.client.protocol.SusClientProtocol.__split_message","title":"<code>__split_message(data)</code>","text":"<p>This function is responsible for splitting a message into packets.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>bytes</code> <p>data to split</p> required <p>Returns:</p> Type Description <code>list[bytes]</code> <p>list of packets</p> Source code in <code>sus/client/protocol.py</code> <pre><code>def __split_message(self, data: bytes) -&gt; list[bytes]:\n    \"\"\"\n    This function is responsible for splitting a message into packets.\n    :param data: data to split\n    :return: list of packets\n    \"\"\"\n    packet_length = self.mtu_estimate - 24\n    return [data[i:i + packet_length] for i in range(0, len(data), packet_length)]\n</code></pre>"},{"location":"client/#sus.client.protocol.SusClientProtocol.__verify_and_decrypt","title":"<code>__verify_and_decrypt(data)</code>","text":"<p>This function is responsible for verifying the packet and decrypting it.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>bytes</code> <p>data to verify and decrypt</p> required <p>Returns:</p> Type Description <code>tuple[None, None] | tuple[int, bytes]</code> <p>packet ID and message, or None if the packet is invalid</p> Source code in <code>sus/client/protocol.py</code> <pre><code>def __verify_and_decrypt(self, data: bytes) -&gt; tuple[None, None] | tuple[int, bytes]:\n    \"\"\"\n    This function is responsible for verifying the packet and decrypting it.\n    :param data: data to verify and decrypt\n    :return: packet ID and message, or None if the packet is invalid\n    \"\"\"\n    try:\n        key = self.sr_mac.update(b\"\\x00\" * 32)\n        p_id = data[:8]\n        payload = data[8:-16]\n        tag = data[-16:]\n        frame = p_id + payload\n        poly1305.Poly1305.verify_tag(key, frame, tag)\n    except poly1305.InvalidSignature:\n        self.logger.error(\"Invalid signature\")\n        return None, None\n\n    p_id = int.from_bytes(p_id, \"little\")\n    message_bytes = self.sr_enc.update(payload)\n    message_length = int.from_bytes(message_bytes[:4], \"little\")\n    message: bytes = message_bytes[4:message_length + 4]\n    # self.logger.info(f\"Received message {p_id} ({message_length} bytes)\")\n    self.last_seen = now()\n    self.server_packet_id = p_id\n    return p_id, message\n</code></pre>"},{"location":"client/#sus.client.protocol.SusClientProtocol.connection_lost","title":"<code>connection_lost(exc)</code>","text":"<p>Called when the connection is lost. Sets the disconnection event.</p> <p>Parameters:</p> Name Type Description Default <code>exc</code> <p>exception raised, if any</p> required Source code in <code>sus/client/protocol.py</code> <pre><code>def connection_lost(self, exc):\n    \"\"\"\n    Called when the connection is lost. Sets the disconnection event.\n    :param exc: exception raised, if any\n    \"\"\"\n    self.logger.warning(\"Connection to server lost\")\n    if exc:\n        self.logger.exception(exc)\n        self.state = ConnectionState.ERROR\n    else:\n        self.state = ConnectionState.DISCONNECTED\n    self.diconnection_event.set()\n</code></pre>"},{"location":"client/#sus.client.protocol.SusClientProtocol.connection_made","title":"<code>connection_made(transport)</code>","text":"<p>This function is called when the connection is established.</p> <p>Parameters:</p> Name Type Description Default <code>transport</code> <code>DatagramTransport</code> <p>transport object, used to send and receive packets</p> required Source code in <code>sus/client/protocol.py</code> <pre><code>def connection_made(self, transport: asyncio.DatagramTransport):\n    \"\"\"\n    This function is called when the connection is established.\n    :param transport: transport object, used to send and receive packets\n    \"\"\"\n    self.transport = transport\n    self.state = ConnectionState.HANDSHAKE\n    self.send(self.protocol_id, self.wallet.token)\n    self.state = ConnectionState.CONNECTED\n    self.last_seen = now()\n    self.logger.debug(\"Handshake complete\")\n    self.handshake_event.set()\n</code></pre>"},{"location":"client/#sus.client.protocol.SusClientProtocol.datagram_received","title":"<code>datagram_received(data, _addr)</code>","text":"<p>This function is called when a packet is received.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>bytes</code> <p>packet data</p> required <code>_addr</code> <code>tuple[str, int]</code> <p>originating address (always the server, unused)</p> required Source code in <code>sus/client/protocol.py</code> <pre><code>def datagram_received(self, data: bytes, _addr: tuple[str, int]):\n    \"\"\"\n    This function is called when a packet is received.\n    :param data: packet data\n    :param _addr: originating address (always the server, unused)\n    \"\"\"\n\n    match self.state:\n        case ConnectionState.CONNECTED:\n            pid, message = self.__verify_and_decrypt(data)\n            self.logger.info(f\"&gt;&gt;&gt; {trail_off(message.decode('utf-8')) if message else None}\")\n            self.handle_message(pid, message)\n</code></pre>"},{"location":"client/#sus.client.protocol.SusClientProtocol.disconnect","title":"<code>disconnect()</code>","text":"<p>Disconnects the client from the server.</p> Source code in <code>sus/client/protocol.py</code> <pre><code>def disconnect(self):\n    \"\"\"\n    Disconnects the client from the server.\n    \"\"\"\n    self.logger.warning(\"Disconnecting from server...\")\n    self.transport.close()\n</code></pre>"},{"location":"client/#sus.client.protocol.SusClientProtocol.handle_message","title":"<code>handle_message(pid, message)</code>","text":"<p>Calls all message handlers asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>pid</code> <code>int</code> <p>packet ID</p> required <code>message</code> <code>bytes</code> <p>message bytes</p> required <p>Returns:</p> Type Description Source code in <code>sus/client/protocol.py</code> <pre><code>def handle_message(self, pid: int, message: bytes):\n    \"\"\"\n    Calls all message handlers asynchronously.\n    :param pid: packet ID\n    :param message: message bytes\n    :return:\n    \"\"\"\n    asyncio.gather(*[handler((\"\", 0), pid, message) for handler in self.message_handlers])\n</code></pre>"},{"location":"client/#sus.client.protocol.SusClientProtocol.send","title":"<code>send(data, token=b'')</code>","text":"<p>This function is responsible for sending a message to the server.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>bytes</code> <p>data to send</p> required <code>token</code> <code>bytes</code> <p>token to include in the first packet. DO NOT INCLUDE THE TOKEN IN SUBSEQUENT PACKETS -- a MalformedPacket error will be raised!</p> <code>b''</code> <p>Raises:</p> Type Description <code>MalformedPacket</code> <p>if the token is included in a subsequent packet</p> Source code in <code>sus/client/protocol.py</code> <pre><code>def send(self, data: bytes, token: bytes = b\"\"):\n    \"\"\"\n    This function is responsible for sending a message to the server.\n    :param data: data to send\n    :param token: token to include in the first packet. DO NOT INCLUDE THE TOKEN IN SUBSEQUENT PACKETS --\n                  a MalformedPacket error will be raised!\n    :raises MalformedPacket: if the token is included in a subsequent packet\n    \"\"\"\n    if self.state not in (ConnectionState.CONNECTED, ConnectionState.HANDSHAKE):\n        return\n    if token and self.client_packet_id != 0:\n        raise MalformedPacket(\"Token can only be included in the first packet\")\n    self.logger.info(f\"&lt;&lt;&lt; {trail_off(data.decode('utf-8'))}\")\n    packets = self.__encrypt_and_tag(data, token)\n    self.logger.info(f\"Sending {len(data)} bytes in {len(packets)} packets\")\n    for packet in packets:\n        self.transport.sendto(packet, None)\n</code></pre>"},{"location":"server/","title":"Server","text":""},{"location":"server/#susserver","title":"SusServer","text":"<p>This class is responsible for managing the server.</p> Source code in <code>sus/server/server.py</code> <pre><code>class SusServer:\n    \"\"\"\n    This class is responsible for managing the server.\n    \"\"\"\n    __protocol: OnePortProtocol\n\n    def __init__(self, addr: Address, psks: str):\n        \"\"\"\n        Initializes the server.\n        :param addr: Tuple containing the address and port to listen on\n        :param psks: Hex encoded private key\n        \"\"\"\n        self.__addr = addr\n        self.__logger = logging.getLogger(\"gatekeeper\")\n\n        self.__psks = X25519PrivateKey.from_private_bytes(bytes.fromhex(psks))\n        self.__ppks = self.__psks.public_key()\n\n        with open(\"server.pub\", \"w\") as f:\n            f.write(self.__ppks.public_bytes(Encoding.Raw, PublicFormat.Raw).hex())\n\n    @property\n    def public_key(self):\n        \"\"\"Server public key\"\"\"\n        return self.__ppks.public_bytes(Encoding.Raw, PublicFormat.Raw).hex()\n\n    @property\n    def address(self):\n        \"\"\"Server address\"\"\"\n        return self.__addr\n\n    async def __garbage_collector(self):\n        \"\"\"\n        This coroutine is responsible for cleaning up inactive clients.\n        \"\"\"\n        try:\n            while not self.__protocol.closed.is_set():\n                await asyncio.sleep(10)\n                self.__protocol.clean()\n        except asyncio.CancelledError:\n            pass\n\n    async def start(self, message_handlers: Iterable[MessageHandler] = None):\n        \"\"\"\n        This coroutine is responsible for starting the server.\n        :param message_handlers: An iterable of message handlers, which are called when a message is received.\n        \"\"\"\n        self.__logger.info(\"Starting server\")\n        self.__logger.info(f\"public key: {self.__ppks.public_bytes(Encoding.Raw, PublicFormat.Raw).hex()}\")\n\n        wallet = Wallet(ppks=self.__ppks, psks=self.__psks)\n\n        # create a protocol instance, this will handle all incoming packets\n        _, self.__protocol = await asyncio.get_running_loop().create_datagram_endpoint(\n            lambda: OnePortProtocol(wallet, message_handlers if message_handlers else []),\n            self.__addr)\n\n        # start the garbage collector.\n        gc_task = asyncio.create_task(self.__garbage_collector())\n\n        # we're done here, wait for the protocol to close.\n        try:\n            await self.__protocol.closed.wait()\n        except asyncio.CancelledError:\n            self.__logger.info(\"Server stopped\")\n        finally:\n            gc_task.cancel()\n            self.__protocol.close()\n\n    async def send(self, addr: Address, msg: bytes):\n        \"\"\"\n        Sends a message to a client.\n        :param addr: Client address\n        :param msg: Message to send\n        \"\"\"\n        await self.__protocol.send(msg, addr)\n\n    async def stop(self):\n        \"\"\"\n        Stops the server.\n        \"\"\"\n        self.__logger.warning(\"Shutting down\")\n        self.__protocol.close()\n</code></pre>"},{"location":"server/#sus.server.SusServer.address","title":"<code>address</code>  <code>property</code>","text":"<p>Server address</p>"},{"location":"server/#sus.server.SusServer.public_key","title":"<code>public_key</code>  <code>property</code>","text":"<p>Server public key</p>"},{"location":"server/#sus.server.SusServer.__garbage_collector","title":"<code>__garbage_collector()</code>  <code>async</code>","text":"<p>This coroutine is responsible for cleaning up inactive clients.</p> Source code in <code>sus/server/server.py</code> <pre><code>async def __garbage_collector(self):\n    \"\"\"\n    This coroutine is responsible for cleaning up inactive clients.\n    \"\"\"\n    try:\n        while not self.__protocol.closed.is_set():\n            await asyncio.sleep(10)\n            self.__protocol.clean()\n    except asyncio.CancelledError:\n        pass\n</code></pre>"},{"location":"server/#sus.server.SusServer.__init__","title":"<code>__init__(addr, psks)</code>","text":"<p>Initializes the server.</p> <p>Parameters:</p> Name Type Description Default <code>addr</code> <code>Address</code> <p>Tuple containing the address and port to listen on</p> required <code>psks</code> <code>str</code> <p>Hex encoded private key</p> required Source code in <code>sus/server/server.py</code> <pre><code>def __init__(self, addr: Address, psks: str):\n    \"\"\"\n    Initializes the server.\n    :param addr: Tuple containing the address and port to listen on\n    :param psks: Hex encoded private key\n    \"\"\"\n    self.__addr = addr\n    self.__logger = logging.getLogger(\"gatekeeper\")\n\n    self.__psks = X25519PrivateKey.from_private_bytes(bytes.fromhex(psks))\n    self.__ppks = self.__psks.public_key()\n\n    with open(\"server.pub\", \"w\") as f:\n        f.write(self.__ppks.public_bytes(Encoding.Raw, PublicFormat.Raw).hex())\n</code></pre>"},{"location":"server/#sus.server.SusServer.send","title":"<code>send(addr, msg)</code>  <code>async</code>","text":"<p>Sends a message to a client.</p> <p>Parameters:</p> Name Type Description Default <code>addr</code> <code>Address</code> <p>Client address</p> required <code>msg</code> <code>bytes</code> <p>Message to send</p> required Source code in <code>sus/server/server.py</code> <pre><code>async def send(self, addr: Address, msg: bytes):\n    \"\"\"\n    Sends a message to a client.\n    :param addr: Client address\n    :param msg: Message to send\n    \"\"\"\n    await self.__protocol.send(msg, addr)\n</code></pre>"},{"location":"server/#sus.server.SusServer.start","title":"<code>start(message_handlers=None)</code>  <code>async</code>","text":"<p>This coroutine is responsible for starting the server.</p> <p>Parameters:</p> Name Type Description Default <code>message_handlers</code> <code>Iterable[MessageHandler]</code> <p>An iterable of message handlers, which are called when a message is received.</p> <code>None</code> Source code in <code>sus/server/server.py</code> <pre><code>async def start(self, message_handlers: Iterable[MessageHandler] = None):\n    \"\"\"\n    This coroutine is responsible for starting the server.\n    :param message_handlers: An iterable of message handlers, which are called when a message is received.\n    \"\"\"\n    self.__logger.info(\"Starting server\")\n    self.__logger.info(f\"public key: {self.__ppks.public_bytes(Encoding.Raw, PublicFormat.Raw).hex()}\")\n\n    wallet = Wallet(ppks=self.__ppks, psks=self.__psks)\n\n    # create a protocol instance, this will handle all incoming packets\n    _, self.__protocol = await asyncio.get_running_loop().create_datagram_endpoint(\n        lambda: OnePortProtocol(wallet, message_handlers if message_handlers else []),\n        self.__addr)\n\n    # start the garbage collector.\n    gc_task = asyncio.create_task(self.__garbage_collector())\n\n    # we're done here, wait for the protocol to close.\n    try:\n        await self.__protocol.closed.wait()\n    except asyncio.CancelledError:\n        self.__logger.info(\"Server stopped\")\n    finally:\n        gc_task.cancel()\n        self.__protocol.close()\n</code></pre>"},{"location":"server/#sus.server.SusServer.stop","title":"<code>stop()</code>  <code>async</code>","text":"<p>Stops the server.</p> Source code in <code>sus/server/server.py</code> <pre><code>async def stop(self):\n    \"\"\"\n    Stops the server.\n    \"\"\"\n    self.__logger.warning(\"Shutting down\")\n    self.__protocol.close()\n</code></pre>"},{"location":"server/#client-handler","title":"Client handler","text":"<p>This class is responsible for handling clients. One instance of this class is created for each client.</p> Source code in <code>sus/server/handler.py</code> <pre><code>class ClientHandler:\n    \"\"\"\n    This class is responsible for handling clients.\n    One instance of this class is created for each client.\n    \"\"\"\n    __cl_enc: AEADDecryptionContext\n    __sr_enc: AEADEncryptionContext\n    __cl_mac: AEADDecryptionContext\n    __sr_mac: AEADEncryptionContext\n\n    __protocol: bytes\n\n    def __init__(self, addr: tuple[str, int], transport: asyncio.DatagramTransport, wallet: Wallet,\n                 message_handlers: Iterable[MessageHandler]):\n        self.__last_seen = now()\n        self.__addr = addr\n        self.__transport = transport\n        self.__message_handlers = set(message_handlers)\n        self.__state = ConnectionState.INITIAL\n\n        self.__logger = logging.getLogger(f\"{addr[0]}:{addr[1]}\")\n\n        self.__logger.info(f\"New client {addr}\")\n\n        wallet.esks = X25519PrivateKey.generate()\n        wallet.epks = wallet.esks.public_key()\n        wallet.ns = urandom(8)\n\n        self.__wallet = wallet\n\n        self.__client_message_id = 0\n        self.__server_message_id = 0\n        self.__client_packet_id = 0\n        self.__server_packet_id = 0\n\n        self.__mtu_estimate = 1500\n\n    @property\n    def is_alive(self):\n        \"\"\"\n        True if the client is not in an error state and has been seen in the last 5 seconds.\n        \"\"\"\n        return self.__state not in (\n            ConnectionState.ERROR, ConnectionState.DISCONNECTED\n        ) and now() - self.__last_seen &lt; 5\n\n    @property\n    def addr(self):\n        \"\"\"Client address.\"\"\"\n        return self.__addr\n\n    @property\n    def last_seen(self):\n        \"\"\"Last time the client was seen, in seconds since the epoch.\"\"\"\n        return self.__last_seen\n\n    @property\n    def protocol(self):\n        return self.__protocol\n\n    def __key_exchange(self):\n        wallet = self.__wallet\n        eces = wallet.esks.exchange(wallet.epkc)\n        ecps = wallet.psks.exchange(wallet.epkc)\n        wallet.shared_secret = blake3(\n            eces + ecps + wallet.nc + wallet.ns +\n            wallet.ppks.public_bytes(Encoding.Raw, PublicFormat.Raw) +\n            wallet.epks.public_bytes(Encoding.Raw, PublicFormat.Raw) +\n            wallet.epkc.public_bytes(Encoding.Raw, PublicFormat.Raw)).digest()\n        self.__logger.debug(f\"shared_secret: {wallet.shared_secret.hex()}\")\n        # noinspection DuplicatedCode\n        self.__cl_enc = Cipher(ChaCha20(wallet.shared_secret, b\"\\x00\" * 8 + CLIENT_ENC_NONCE), None).decryptor()\n        self.__sr_enc = Cipher(ChaCha20(wallet.shared_secret, b\"\\x00\" * 8 + SERVER_ENC_NONCE), None).encryptor()\n        self.__cl_mac = Cipher(ChaCha20(wallet.shared_secret, b\"\\x00\" * 8 + CLIENT_MAC_NONCE), None).decryptor()\n        self.__sr_mac = Cipher(ChaCha20(wallet.shared_secret, b\"\\x00\" * 8 + SERVER_MAC_NONCE), None).encryptor()\n\n    def __verify_and_decrypt(self, data: bytes) -&gt; bytes | None:\n        try:\n            p_id = int.from_bytes(data[:8], \"little\")\n            key = self.__cl_mac.update(b\"\\x00\" * 32)\n            payload = data[8:-16]\n            tag = data[-16:]\n            poly1305.Poly1305.verify_tag(key, data[:8] + payload, tag)\n        except InvalidSignature:\n            self.__logger.error(\"Invalid signature\")\n            return None\n\n        # special case for first packet\n        if p_id == 0:\n            payload = payload[32:]\n            self.__logger.debug(f\"--- {trail_off(payload.hex())}\")\n\n        message_bytes = self.__cl_enc.update(payload)\n        message_length = int.from_bytes(message_bytes[:4], \"little\")\n        message = message_bytes[4:message_length + 4]\n        self.__logger.info(f\"Received message {p_id} ({message_length} bytes)\")\n        self.__client_packet_id = p_id\n        return message\n\n    def __encrypt_and_tag(self, data: bytes) -&gt; list[bytes]:\n        message_bytes = len(data).to_bytes(4, \"little\") + data\n        packet_length = self.__mtu_estimate - 24\n        padded_message_bytes = message_bytes + b\"\\x00\" * (\n                packet_length - ((len(message_bytes)) % packet_length))\n\n        ciphertext = self.__sr_enc.update(padded_message_bytes)\n        self.__logger.debug(f\"--- {trail_off(ciphertext.hex())}\")\n\n        payloads = self.__split_message(ciphertext)\n\n        packets = []\n        for payload in payloads:\n            key = self.__sr_mac.update(b\"\\x00\" * 32)\n            p_id = self.__client_packet_id.to_bytes(8, \"little\")\n            frame = p_id + payload\n            tag = poly1305.Poly1305.generate_tag(key, frame)\n            packets.append(frame + tag)\n            self.__client_packet_id += 1\n        return packets\n\n    def __split_message(self, data: bytes) -&gt; list[bytes]:\n        packet_length = self.__mtu_estimate - 24\n        return [data[i:i + packet_length] for i in range(0, len(data), packet_length)]\n\n    def __initial(self, data):\n        if len(data) != 40:\n            self.__logger.error(\"Invalid handshake packet\")\n            raise MalformedPacket(\"Invalid handshake packet\")\n        wallet = self.__wallet\n        wallet.epkc = X25519PublicKey.from_public_bytes(data[:32])\n        wallet.nc = data[32:]\n\n        self.__state = ConnectionState.HANDSHAKE\n        self.__transport.sendto((wallet.epks.public_bytes(Encoding.Raw, PublicFormat.Raw) + wallet.ns), self.__addr)\n\n    def __handshake(self, data) -&gt; None:\n        if len(data) &lt; 40:\n            self.__logger.error(\"Invalid handshake packet\")\n            self.__state = ConnectionState.ERROR\n            raise MalformedPacket(\"Invalid handshake packet\")\n\n        wallet = self.__wallet\n\n        wallet.token = blake3(wallet.epkc.public_bytes(Encoding.Raw, PublicFormat.Raw) +\n                              wallet.epks.public_bytes(Encoding.Raw, PublicFormat.Raw) +\n                              wallet.nc + wallet.ns).digest()\n        client_token = data[8:40]\n\n        self.__logger.debug(f\"token: {client_token.hex()}\")\n\n        if client_token != wallet.token:\n            self.__logger.debug(f\"ours : {self.__wallet.token.hex()}\")\n            self.__logger.error(\"token mismatch!\")\n            raise HandsakeError(\"Token mismatch\")\n\n        self.__logger.debug(\"token: OK\")\n\n        self.__key_exchange()\n\n        message = self.__verify_and_decrypt(data)\n        if message is None:\n            self.__state = ConnectionState.ERROR\n            raise HandsakeError(\"Invalid handshake packet (missing protocol)\")\n\n        self.__state = ConnectionState.CONNECTED\n        self.__protocol = message\n        self.__logger.info(\"Handshake complete\")\n        self.__logger.debug(f\"protocol: {message.decode('utf-8')}\")\n\n    def __connected(self, data):\n        message = self.__verify_and_decrypt(data)\n        self.__logger.info(f\"&gt;&gt;&gt; {trail_off(message.decode('utf-8')) if message else None}\")\n\n        if message:\n            # send to all handlers\n            asyncio.gather(*[\n                handler(self.addr, self.__client_message_id, message)\n                for handler in self.__message_handlers\n            ])\n\n    def __disconnected(self, data):\n        raise NotImplementedError\n\n    def __error(self, data):\n        raise NotImplementedError\n\n    def handle(self, data: bytes):\n        \"\"\"\n        Handles incoming packets.\n        :param data: packet data\n        \"\"\"\n        self.__last_seen = now()\n\n        match self.__state:\n            case ConnectionState.INITIAL:\n                self.__initial(data)\n            case ConnectionState.HANDSHAKE:\n                self.__handshake(data)\n            case ConnectionState.CONNECTED:\n                self.__connected(data)\n            case ConnectionState.DISCONNECTED:\n                self.__disconnected(data)\n            case ConnectionState.ERROR:\n                self.__error(data)\n\n    async def send(self, data: bytes):\n        \"\"\"\n        Sends a message to the client.\n        :param data: data to send\n        \"\"\"\n        if self.__state not in (ConnectionState.CONNECTED, ConnectionState.HANDSHAKE):\n            return\n        self.__logger.info(f\"&lt;&lt;&lt; {trail_off(data.decode('utf-8'))}\")\n        packets = self.__encrypt_and_tag(data)\n        self.__logger.info(f\"Sending {len(data)} bytes in {len(packets)} packets\")\n        for packet in packets:\n            self.__transport.sendto(packet, self.__addr)\n\n    def add_message_handler(self, handler: MessageHandler):\n        \"\"\"\n        Adds a message handler. This handler will be called when a message is received.\n        :param handler: Awaitable handler function\n        \"\"\"\n        self.__message_handlers.add(handler)\n</code></pre>"},{"location":"server/#sus.server.handler.ClientHandler.addr","title":"<code>addr</code>  <code>property</code>","text":"<p>Client address.</p>"},{"location":"server/#sus.server.handler.ClientHandler.is_alive","title":"<code>is_alive</code>  <code>property</code>","text":"<p>True if the client is not in an error state and has been seen in the last 5 seconds.</p>"},{"location":"server/#sus.server.handler.ClientHandler.last_seen","title":"<code>last_seen</code>  <code>property</code>","text":"<p>Last time the client was seen, in seconds since the epoch.</p>"},{"location":"server/#sus.server.handler.ClientHandler.add_message_handler","title":"<code>add_message_handler(handler)</code>","text":"<p>Adds a message handler. This handler will be called when a message is received.</p> <p>Parameters:</p> Name Type Description Default <code>handler</code> <code>MessageHandler</code> <p>Awaitable handler function</p> required Source code in <code>sus/server/handler.py</code> <pre><code>def add_message_handler(self, handler: MessageHandler):\n    \"\"\"\n    Adds a message handler. This handler will be called when a message is received.\n    :param handler: Awaitable handler function\n    \"\"\"\n    self.__message_handlers.add(handler)\n</code></pre>"},{"location":"server/#sus.server.handler.ClientHandler.handle","title":"<code>handle(data)</code>","text":"<p>Handles incoming packets.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>bytes</code> <p>packet data</p> required Source code in <code>sus/server/handler.py</code> <pre><code>def handle(self, data: bytes):\n    \"\"\"\n    Handles incoming packets.\n    :param data: packet data\n    \"\"\"\n    self.__last_seen = now()\n\n    match self.__state:\n        case ConnectionState.INITIAL:\n            self.__initial(data)\n        case ConnectionState.HANDSHAKE:\n            self.__handshake(data)\n        case ConnectionState.CONNECTED:\n            self.__connected(data)\n        case ConnectionState.DISCONNECTED:\n            self.__disconnected(data)\n        case ConnectionState.ERROR:\n            self.__error(data)\n</code></pre>"},{"location":"server/#sus.server.handler.ClientHandler.send","title":"<code>send(data)</code>  <code>async</code>","text":"<p>Sends a message to the client.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>bytes</code> <p>data to send</p> required Source code in <code>sus/server/handler.py</code> <pre><code>async def send(self, data: bytes):\n    \"\"\"\n    Sends a message to the client.\n    :param data: data to send\n    \"\"\"\n    if self.__state not in (ConnectionState.CONNECTED, ConnectionState.HANDSHAKE):\n        return\n    self.__logger.info(f\"&lt;&lt;&lt; {trail_off(data.decode('utf-8'))}\")\n    packets = self.__encrypt_and_tag(data)\n    self.__logger.info(f\"Sending {len(data)} bytes in {len(packets)} packets\")\n    for packet in packets:\n        self.__transport.sendto(packet, self.__addr)\n</code></pre>"},{"location":"server/#protocol","title":"Protocol","text":"<p>             Bases: <code>DatagramProtocol</code></p> <p>This class is responsible for handling the UDP protocol. It matches incoming packets to clients and handles the handshake.</p> Source code in <code>sus/server/protocol.py</code> <pre><code>class OnePortProtocol(asyncio.DatagramProtocol):\n    \"\"\"\n    This class is responsible for handling the UDP protocol.\n    It matches incoming packets to clients and handles the handshake.\n    \"\"\"\n    __transport: asyncio.DatagramTransport\n\n    def __init__(self, wallet: Wallet, message_handlers: Iterable[MessageHandler]):\n        super().__init__()\n        self.__wallet = wallet\n        self.__message_handlers = message_handlers\n\n        self.__clients: dict[tuple[str, int], ClientHandler] = dict()\n        self.__logger = logging.getLogger(f\"OnePort\")\n\n        self.closed = asyncio.Event()\n\n    def connection_made(self, transport: asyncio.DatagramTransport):\n        self.__transport = transport\n        self.__logger.info(f\"Listening on port {transport.get_extra_info('sockname')[1]}\")\n\n    def error_received(self, exc):\n        self.__logger.exception(exc)\n\n    def datagram_received(self, data, addr):\n        if addr not in self.__clients:\n            try:\n                c = ClientHandler(addr, self.__transport, self.__wallet, self.__message_handlers)\n            except (HandsakeError, MalformedPacket):\n                self.__logger.error(f\"Handshake failed with {addr}\")\n                return\n            self.__clients[addr] = c\n\n        handler = self.__clients[addr]\n\n        try:\n            handler.handle(data)\n        except HandsakeError:\n            self.__logger.error(f\"Handshake failed with {addr}\")\n            del self.__clients[addr]\n            self.close()\n        except MalformedPacket:\n            self.__logger.error(f\"Malformed packet from {addr}\")\n            del self.__clients[addr]\n\n    async def send(self, data: bytes, addr: tuple[str, int]):\n        if addr not in self.__clients:\n            self.__logger.error(f\"Attempted to send to {addr} but they are not connected\")\n            return\n        await self.__clients[addr].send(data)\n\n    def add_message_handler(self, handler: MessageHandler, addr: tuple[str, int]):\n        self.__clients[addr].add_message_handler(handler)\n\n    def clean(self):\n        \"\"\"\n        Removes inactive clients.\n        \"\"\"\n        for addr in list(self.__clients.keys()):\n            if not self.__clients[addr].is_alive:\n                del self.__clients[addr]\n\n    def close(self):\n        self.__transport.close()\n\n    def connection_lost(self, exc):\n        self.__logger.info(\"Connection closed\")\n        self.closed.set()\n</code></pre>"},{"location":"server/#sus.server.protocol.OnePortProtocol.clean","title":"<code>clean()</code>","text":"<p>Removes inactive clients.</p> Source code in <code>sus/server/protocol.py</code> <pre><code>def clean(self):\n    \"\"\"\n    Removes inactive clients.\n    \"\"\"\n    for addr in list(self.__clients.keys()):\n        if not self.__clients[addr].is_alive:\n            del self.__clients[addr]\n</code></pre>"},{"location":"sus/","title":"The Sus Protocol","text":"<p>Sus is a secure and asynchronous protocol for sending messages between two parties. It is designed to be easy to use and to be secure against active and passive attacks. Sus makes it easy to send messages between two parties without having to worry about encryption, authentication, or message ordering.</p>"},{"location":"sus/#features","title":"Features","text":"<ul> <li>Secure - Sus is secure against active and passive attacks. It uses the XChaCha20-Poly1305 authenticated encryption algorithm to encrypt and authenticate messages. It uses X25519 for key exchange and Ed25519 for authentication.</li> <li>Asynchronous - Sus is asynchronous and uses UDP as the underlying transport protocol. This means that messages are not guaranteed to arrive in the same order as they were sent. Sus takes care of reordering messages and discarding duplicate messages.</li> <li>Easy to use - Sus is designed to be easy to use. It is easy to set up a Sus network and send messages between two parties.</li> </ul>"},{"location":"sus/#design","title":"Design","text":"<pre><code>sequenceDiagram\n    participant A as Alice\n    participant B as Bob\n\n    A-&gt;&gt;B: key, nonce\n    B-&gt;&gt;A: key, nonce\n    A-&gt;&gt;B: token</code></pre>"},{"location":"sus/#key-exchange","title":"Key exchange","text":"<p>The key exchange is done using the X25519 key exchange algorithm. The key exchange is done in the following steps:</p> <ol> <li>Alice generates a key pair and sends the public key to Bob.</li> <li>Bob generates a key pair and sends the public key to Alice.</li> <li>Alice generates a shared secret using her private key and Bob's public key.</li> <li>Bob generates a shared secret using his private key and Alice's public key.</li> <li>Alice and Bob now have the same shared secret.</li> </ol> <p>something something secret key</p>"}]}